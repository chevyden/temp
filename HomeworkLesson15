====Test====

Создайте программу которая выведет ответы на поставленые вопросы (вопросы выводите так-же) 



1. Назовите принципы ООП и расскажите о каждом.
 - Абстракция - это выделение самых важных и значимых характеристик и информации об объекте, 
 в то же время отбрасывание не значительных. Иными словами - использование простых вещей для описания чего-то сложного.
 - Инкапсуляция - это принцип, при котором атрибуты и поведение объекта объединяются в одном классе, 
 внутренняя реализация объекта скрывается от пользователя(других программистов), 
 а для работы с объектом предоставляется открытый интерфейс.
 - Наследование - это возможность описать новый класс на основе существующего (родительского). 
 При этом свойства и функции родительского класса доступны новым классам. Это позволяет избавиться от повторения кода.
 - Полиморфизм - возможность объектов с одинаковой спецификацией иметь различную реализацию.

2. Дайте определение понятию “класс”.
 - Это шаблон-описание общих характеристик для создание объектов. Это описание может состоять из характеристик 
 объектов и описания поведения объекта.

3. Что такое поле/атрибут класса?
 - Это переменные в которых хранятся данные объекта.

4. Как правильно организовать доступ к полям класса?
 - применяя принцип инкапсуляции, кагда не возможно присвоить значение полю обращаясь напрямую 
 (используя модификатор доступа private), а возможность предоставлена применяя доступные методы 
 типа set(присвоить значение) и get(считать значение).

5. Дайте определение понятию “конструктор”.
 - это метод, отвечающий за создание нового объекта с параметрами или без, вызывается в любом 
 случае при создании инстанса класса. Конструктор не имеет возвращаемого типа и 
 называется так же, как класс, объект которого он создает. 

6. Чем отличаются конструкторы по-умолчанию, копирования и конструктор с параметрами?
 - конмтруктор по умолчанию не принимает никаких параметров;
 - консртуктор копирования принимает на вход объект класса;
 - конструктор с параметрами принимает на вход параметры, необходимые для инициализации полей. 

7. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.
 - private - предоставляет видимость только внутри данного класса;
 - default или package - установлен по умолчанию(если не написать никакой модификатор)
   предоставляет доступ внутри пакета, нет доступа вне пакета и наследникам;
 - protected - предоставляет доступ внутри пакета и классам наследникам;
 - public - предоставляет доступ из любого места программыю

8. Расскажите об особенностях класса с единственным закрытым (private) конструктором.
 - невозможно будет создать инстанс такого класса, а также невозможно унаследоваться от такого класса.

9. О чем говорят ключевые слова “this”, “super”, где и как их можно использовать?
 - слово “this” дает возможность обращения к членам текущего класса, а слово “super” дает возможность 
   обращения к членам родительского класаю  

10. Дайте определение понятию “метод”.
 - это функция или подпрограмма нацеленная на решение небольшой задачи, реализованая законченным наббором команд.

11. Что такое сигнатура метода?
 - это имя метода и входные параметры с учетом их порядка.

12. Какие методы называются перегруженными?
 - это методы, которые имеют одинаковые имена, но разный набор параметров или порядок параметров.

13. Могут ли нестатические методы перегрузить статические?
 - в таком случае мы получим програмно разные методы.

14. Расскажите про переопределение методов.
 - переопределенный метод, это метод класса наследника, имеющий одинаковою сигнатуру с методом
   родительского класса.

15. Может ли метод принимать разное количество параметров (аргументы переменной длины)?
 - да, может, сигнатура будет принимать например вид: privat void m(int ... ints){}

16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
 - сузить уровень доступа нельзя, а тип возвращаемого значения можно

17. Как получить доступ к переопределенным методам родительского класса?
 - с помощью ключевого слова super.

18. Какие преобразования называются нисходящими и восходящими?
 - от родителя к наследникам - нисходящее преобразование,
 - от наследника к родителям - восходящее преобразование.

19. Чем отличается переопределение от перегрузки?
 - перегрузка - это использование метода с одинаковым именем, но иными параметрами,
 а перепределение - это использование переделанного/измененного метода.

20. Где можно инициализировать статические/нестатические поля?
 - статические - при объявлении, в статическом или динамическом блоке инициализации; 
 - нестатические - при объявлении, в динамическом блоке инициализации или в конструкторе.

21. Зачем нужен оператор instanceof?
 - для проверки является ли какой-то инстанс инстансом определенного класса или его наследников. 

22. Зачем нужны и какие бывают блоки инициализации?
 - блоки инициализации - это набор строк, в которых инициализируются(присваиваются значения) поля, 
размещаются в фигурных скобках в классе. Бывают статические(для инициализации статических переменных) 
и нестатические.  

23. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?
 - происходит каскадный вызов: сначала статические блоки инициализации предка, а потом потомка, 
после чего нестатические блоки инициализации и конструкторы предка, а потом потомка.

24. Где и для чего используется модификатор abstract?
 - модификатор abstract нужен для создания абстрактных методов(метод не имеет реализации, 
но должен быть реализован в наследнике) и абстрактных классов(если есть хоть один абстрактный метод, 
то класс - абстрактный). Инстанс абстрактного классы создать не возможно. Абстракция нужна для определения
какой-то функции, которая должна быть реализована в наследниках.

25. Можно ли объявить метод абстрактным и статическим одновременно?
 - нет.

26. Что означает ключевое слово static?
 - ключевое слово static означает, что филд или метод принадлежит классу, а не инстансу класса.
Таким образом доступ к static члену класса будет возможен без создания инстанса класса. При этом,
static методам доступны только static методы и переменные, а также в них не применимы “this” и “super”. 

27. К каким конструкциям Java применим модификатор static?
 - поле класса,
 - метод,
 - nested класс, 
 - импортируемый класс.

28. Можно ли перегрузить static метод?
 - можно.

29. Что такое статический класс, какие особенности его использования?
 - это вложенный класс, который имеет доступ только к статическим полям и методам внешнего класса. 
Доступ к нестатическим полям и методам можно получить, создав инстанс внешнего класса.


30. Какие особенности инициализации final static переменных?
 - инициализируются при объявлении переменной имя переменной пишется заглавными буквами вместо 
пробела ставится нижнее подчеркивание.

31. Как влияет модификатор static на класс/метод/поле?
 - static класс - имеет доступ только к статическим полям и методам внешнего класса, доступ к нестатическим 
полям и методам можно получить, создав инстанс внешнего класса
 - static метод - принадлежит классу, а не инстансу класса, доступны только static методы и переменные.
 - static поле  - принадлежит классу, а не инстансу класса

32. О чем говорит ключевое слово final?
 - говорит о том, что если: 
	final класс - наследоваться от такого класса не получится;
	final поле - не может быть изменено после инициализации (константа);
	final метод - не получится переопределить.

33. Дайте определение понятию “интерфейс”.
 - интерфейс - это "контракт" на реализацию классов, которые его имплементтируют.
Иными словами полностью абстрактный класс с набором нереализованных методов, которые обязательны к реализации.

34. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
 - поля - final static;
 - методы - public abstract.

35. Почему нельзя объявить метод интерфейса с модификатором final или static?
 - static - можно, если в методе будеть тело;
 - final - не имеет смысла, так как методы должны быть реализованы.

36. Какие типы классов бывают в java (вложенные… и.т.д.)
 - вложенные внутренние классы;
 - статические вложенные классы;
 - внутренние классы в локальном методе;
 - анонимные классы.

37. Какие особенности создания вложенных классов: простых и статических.
 - Статический вложенный класс(Static nested class) - может иметь только статические методы, 
имеет доступ к статическим полям и методам внешнего класса;
 - Вложенный внутренний класс(inner class) - может получить доступ к любому приватному полю 
или методу экземпляра внешнего класса, может иметь любой модификатор доступа.

38. Какие классы называются анонимными?
 - это класс без имени.

39. Как связан любой пользовательский класс с классом Object?
 - пользовательский класс наследуется от класса Object.

40. Расскажите про каждый из методов класса Object.
 - equals(Object obj) стравнение объектов; 
 - Object clone() - создает новый объект, не отличающийся от клонируемого; 
 - getClass() - получает класс объекта;
 - hashCode() - возвращает хеш-код, связанный с вызывающим объектом;
 - toString() - возвращает символьную строку, описывающую объект;
 - notify(), notifyAll(), wait() - методы для работы с потоками.

41. Чем отличается абстрактный класс от интерфейса, в каких случаях что вы будете использовать?
 - интерфейс может быть реализован классами не связаны друг с другом наследованием, а абстрактный 
класс реальзуется только его наследниками.
 - в абстрактном классе могут быть реализованы методы, в интерфейсе могут быть реализованны 
только статические методы.
 - если необходим аналог множественного наследования, то необходимо использовать интерфейс, так как 
класс может имплементировать несколько интерфейсов, но наследоваться может только от 
дного абстрактного класса.

42. Можно ли получить доступ к private переменным класса и если да, то каким образом?
 - используя методы Reflection API.

43. Если у класса-родителя есть метод, объявленный как private, может ли наследник расширить его видимость? 
А если protected? А сузить видимость?
 - private дает доступ только внутри класса в котором объявлен метод, поэтому разширить или сузить нельзя.
 - protected разширять видимость можно, а сужать нет.

44. Имеет ли смысл объявлять метод private final?
 - нет, private метод и так виден только в текущем классе, поэтому не может быть переопределен.

45. Какие особенности инициализации final переменных?
 - если они объявленны не static, то они инициализируются в конструкторе, даже если не были объявлены не в нем; 
 - если static, то либо при создании переменной, либо при первом обращении к этой переменной и только один раз.

46. Что будет, если единственный конструктор класса объявлен как final?
 - конструктор не может быть final. Не скомпилируется программа.
